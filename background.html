<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. Background &mdash; Multi-Party Encrypted Messaging Protocol design document 0.1-4-g75e6b2d</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/project.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1-4-g75e6b2d',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="top" title="Multi-Party Encrypted Messaging Protocol design document 0.1-4-g75e6b2d" href="index.html" />
    <link rel="next" title="2. Topics" href="topics.html" />
    <link rel="prev" title="Multi-Party Encrypted Messaging Protocol" href="index.html" />
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            "HTML-CSS": {
                // switch this off, it tends to make fonts too large
                matchFontHeight: false,
                // see https://docs.mathjax.org/en/v2.5-latest/options/HTML-CSS.html for valid values
                // most other ones don't look so good with the surrounding sans-serif Sphinx text
                availableFonts: ["Neo-Euler"],
                preferredFont: "Neo-Euler",
                webFont: "Neo-Euler",
            },
        });
    </script>

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="topics.html" title="2. Topics"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Multi-Party Encrypted Messaging Protocol"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Multi-Party Encrypted Messaging Protocol design document 0.1-4-g75e6b2d</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="background">
<h1>1. Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h1>
<p>This chapter is not about our work, but a general discussion of secure group
communications &#8211; our model of what it is, and &#8220;ideal&#8221; properties that <em>might</em>
be achieved. It is the longest chapter, so readers already familiar with such
topics may prefer to skip to the next one.</p>
<p>Often, lists of security properties can seem arbitrary, with technical names
that seem unrelated to each other. We take a more methodical approach, and try
to classify these properties within a general framework. To be clear, this is
neither formal nor precise, and our own project goals only focus on a subset of
these. Our motivation is to <em>enumerate</em> all options from a <em>protocol design</em>
perspective, for future reference and for comparison with other projects that
focus on a different subset. It offers some assurance that we haven&#8217;t missed
anything, provides better understanding of relationships between properties,
and suggests natural separations for solving different concerns.</p>
<p>There is other work, previous and ongoing, that gives more precise treatments
of the topics below. We encourage interested readers to explore those for
themselves, as well as future research on classification and enumeration.</p>
<div class="section" id="model-and-mechanics">
<h2>1.1. Model and mechanics<a class="headerlink" href="#model-and-mechanics" title="Permalink to this headline">¶</a></h2>
<p>First, we present an abstract conceptual model of a <em>private group session</em> and
introduce some terminology. Secure communication systems generally consist of
the following steps:</p>
<ol class="arabic simple" start="0">
<li>Identity (long-term) key validation.</li>
<li>Session membership change (e.g. establishment or optional termination).</li>
<li>Session communication.</li>
</ol>
<p>We only concern ourselves with (1) and (2). We assume that (0), a.k.a. the &#8220;PKI
problem&#8221;, is handled by an external component that the application interacts
directly with, bypassing our components. Even if it is not handled safely, this
does not affect the <em>functionality</em> of our components; but the application
should display a warning <a class="footnote-reference" href="#keyv" id="id1">[1]</a> and record this fact and/or have the user
complete that step retroactively.</p>
<p>A <strong>session</strong> (as viewed by a subject member, at a given time) is formed from a
set of transport <em>packets</em>, which the protocol interprets logically as a set of
messages and a <em>session membership</em>. Each <strong>message</strong> has a single <em>author</em> and
a set of <em>readers</em>; the <em>message membership</em> is the union of these. Messages
have an order relative to each other, that may be represented (without loss of
information) as a set of <em>parent messages</em> for each message; and relative to
the session boundary, i.e. when the subject decides to join and part.</p>
<p>Whilst part of a session, members may change the session membership, send new
messages to the current session membership, and receive these events from each
other. Events are only readable to those who are part of the session membership
of the event generator, when they generated it. For example, joining members
cannot read messages that were written before the author saw them join (unless
an old member leaks the contents to them, outside of the protocol). <a class="footnote-reference" href="#rejn" id="id2">[2]</a></p>
<p>On the transport level, we assume an efficient packet broadcast operation, that
costs time near-constant in the number of recipients, and bandwidth near-linear
(or less) in the number of recipients or the size of the packet. Note that the
<em>sender</em> and <em>recipients</em> of a transport packet are concepts distinct from the
author and readers of a logical message; our choice of terminology tries to
make this clear and unambiguous.</p>
<p>For completeness, we observe that a real system often unintentionally generates
&#8220;side channel&#8221; information, beyond the purpose of the model. This includes the
time, space, energy cost of computation; the size, place of storage; the time,
size, route of communications; and probably more that we&#8217;ve missed. Often it is
impossible to avoid generating some of this information.</p>
<p>In summary, we&#8217;ve enumerated the broad categories of information in our model:
membership, ordering, content, and side channels. Next, we&#8217;ll discuss and
classify the security properties we might want, then consider these properties
in the context of each of these categories.</p>
<table class="docutils footnote" frame="void" id="keyv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For example, &#8220;WARNING: the authenticity and privacy of this session
is dependant on the unknown validity of the binding $key ↔
$user&#8221; or perhaps something less technical.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rejn" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>We don&#8217;t yet have a good model of what it should precisely mean to
<em>rejoin</em> a session. This &#8220;happens to work&#8221; with what we&#8217;ve implemented, but
is not easily extensible to asynchronous messaging. Specifically, it&#8217;s
unclear how best to consistently define the relative ordering of messages
across all members. We will explore this topic in more depth in the future.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="security-properties">
<h2>1.2. Security properties<a class="headerlink" href="#security-properties" title="Permalink to this headline">¶</a></h2>
<p>In any information network, we produce and consume information. This could be
explicit (e.g. contents) or implicit (e.g. metadata). From this very general
observation, we can suggest a few fundamental security properties:</p>
<dl class="docutils">
<dt><strong>Efficiency</strong></dt>
<dd>Nobody should be able to cause anyone to spend resources (i.e. time, memory,
or bandwidth) much greater than what the initiator spent.</dd>
<dt><strong>Authenticity</strong></dt>
<dd>Information should be associated with a proof, either explicit or implicit,
that consumers may use to verify the truth of it.</dd>
<dt><strong>Confidentiality</strong></dt>
<dd>Only the intended consumers should be able to access and interpret the
information.</dd>
</dl>
<p>We&#8217;ll consider authenticity and confidentiality as applied to the categories of
information we listed above. (Efficiency is more fiddly and we&#8217;ll discuss it in
narrower terms later, applied to specific parts of our protocol system.)</p>
<p>Here is a summary of current known best techniques for achieving each property.
Though we don&#8217;t try to achieve all of them in our protocol system, being aware
of them allows us to avoid decisions that destroy the possibility to achieve
them in the future.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&nbsp;</th>
<th class="head">Authenticity</th>
<th class="head">Confidentiality</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Existence</td>
<td>automatic</td>
<td>research topic</td>
</tr>
<tr class="row-odd"><td>Side channels</td>
<td>unneeded</td>
<td>research topic</td>
</tr>
<tr class="row-even"><td>Membership</td>
<td>via crypto</td>
<td>research topic</td>
</tr>
<tr class="row-odd"><td>Ordering</td>
<td>via crypto</td>
<td>not explored yet</td>
</tr>
<tr class="row-even"><td>Contents</td>
<td>via crypto</td>
<td>via crypto</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Auth. of session existence</dt>
<dd>This is achieved automatically by authenticity of any of the other types; we
don&#8217;t need to worry about it on its own.</dd>
<dt>Conf. of session existence</dt>
<dd>This is the hardest to achieve, and is an ongoing research topic. This is the
scenario where the user must hide the fact that they are merely <em>using the
protocol</em>, even if the attacker knows nothing about any actual sessions. Not
only does it require confidentiality of all the other types of information,
but also obfuscation, steganography, and/or anti-forensics techniques.</dd>
<dt>Auth. of side channels</dt>
<dd>We don&#8217;t care about the authenticity of something we didn&#8217;t intend to
communicate in the first place.</dd>
<dt>Conf. of side channels</dt>
<dd>Still a research topic, this is a concern because it may be used to break
the confidentiality of other types of information.</dd>
<dt>Auth. of membership</dt>
<dd><p class="first">There is some depth to this. The first choice is whether a distinct <em>change
session membership</em> operation should exist outside of sending messages. &#8220;Yes&#8221;
means that (e.g.) you can add someone to the session, and they will know this
(maybe a window will pop up on their side) even if you don&#8217;t send them any
messages. &#8220;No&#8221; means that membership changes must always be associated with
an actual message that effects this change. This is up to the application;
though &#8220;no&#8221; is generally more suited for asynchronous messaging.</p>
<p>If &#8220;yes&#8221;, we must consider <em>entity aliveness</em> in our membership protocol.
This is the property that <em>if</em> we complete the protocol successfully, <em>then</em>
we are also sure that our peers have done the same thing. This requires a key
confirmation step from joining members, making the protocol last at least 2
rounds. If we don&#8217;t consider this, then we may use shorter protocols, but
then our peers might not know that we changed the session membership until we
send them a message, which makes the &#8220;yes&#8221; choice less useful.</p>
<p class="last">In both cases, authenticating (adding a proof of authorship to) messages is
not enough to verify membership, since packets may get dropped, perhaps even
against different recipients. We need to wait for all readers to send a reply
back to acknowledge their receipt. This is known as <em>reliability</em> (when the
author checks it) or <em>consistency</em> (when a reader checks the other readers).</p>
</dd>
<dt>Conf. of membership</dt>
<dd><p class="first">This is more commonly called <em>unlinkability</em> and is an ongoing research
topic. One major difficulty is that the information may be inferred from many
different sources, often implicit in the implementation or in the choice of
transport, and not explicit in the model. For example:</p>
<ul class="last simple">
<li>It may be inferred from side channels, such as timing or packet size
correlations at the senders and recipients, or transport-defined headers
that contain routing information. So, we need routing anonymity and padding
or chaff mechanisms to protect against this line of attack.</li>
<li>It may be inferred from content, such as raw signatures or public keys.
So, we need confidential authentication mechanisms (defined later) as well
as obfuscated transport protocols to protect against this line of attack.</li>
</ul>
</dd>
<dt>Auth. of ordering</dt>
<dd><p class="first">The two types of ordering we identified earlier are: ordering of messages
within a session, and session boundary ordering relative to local events. The
latter is more commonly known as <em>freshness</em>.</p>
<p>Other systems sometimes claim freshness based on some idea of an absolute
clock, but this requires trusting third-party infrastructure and/or the
user&#8217;s local clock being correct. We prefer to avoid such approaches as it
makes the guarantees less clear.</p>
<p class="last">Cryptographic guarantees are best; e.g., if we witness (in <em>any order</em>) a
hash and its pre-image, then we are sure that the former was generated (i.e.
authored) <em>after</em> the latter. To link remote events to our own time, we can
arrange for the pre-image to be derived from some unpredictable local event
such as generating a random nonce.</p>
</dd>
<dt>Conf. of ordering</dt>
<dd>This hasn&#8217;t been explored explicitly in the wider literature, but could help
to break confidentiality of other types of information. It&#8217;s out of scope for
us to consider it in more detail right now; sorry.</dd>
<dt>Auth. of contents</dt>
<dd>This is a straightforward application of cryptography. To be clear, this is
about proving that the author intended to send us the contents. Whether the
claims in it are true (including any implicit claim that the contents weren&#8217;t
copied from elsewhere) is another matter. We&#8217;ll refer back to this later.</dd>
<dt>Conf. of contents</dt>
<dd>This is a straightforward application of cryptography.</dd>
</dl>
<p>In conclusion, we&#8217;ve taken a top-down approach to identify security properties
that are direct high-level user concerns in a general <em>private group session</em>.
We have not considered lower-level properties (e.g. <em>contributiveness</em>, <em>key
control</em>) here since they are only relevant to specific implementations; but we
will discuss such properties <em>when and if</em> they might affect the ones above.</p>
</div>
<div class="section" id="threat-models">
<h2>1.3. Threat models<a class="headerlink" href="#threat-models" title="Permalink to this headline">¶</a></h2>
<p>Attackers with different powers may try to break any of the above properties.
First, let&#8217;s define and describe these powers:</p>
<dl class="docutils">
<dt>Active communications attack (on the entire transport)</dt>
<dd><p class="first">This is the standard attack that all modern communications systems should
protect against &#8211; i.e. a transport-level &#8220;man in the middle&#8221; who can inject,
drop, replay and reorder packets. Generally (and in practise mostly) channels
are bi-directional &#8211; so we must assume that the attacker, if they are able
to target one member, then they are able to target all members, by attacking
the channel in the opposite direction.</p>
<p class="last">Since this a baseline requirement, the powers defined below should be taken
to <em>include</em> the ability to actively attack the transport during any attack.</p>
</dd>
<dt>Leak identity secrets (of some targets)</dt>
<dd>This refers to all of the secret material needed for a subject to establish a
new session, e.g. with someone that they&#8217;ve never communicated with before.
By definition, this is secret only to the subject.</dd>
<dt>Leak session secrets (of some targets)</dt>
<dd><p class="first">This refers to all of the secret material needed for a subject to continue
participating in a session they&#8217;re already part of. This may be secret to
only the subject, or shared across all members, or a combination of both.</p>
<p class="last">This may <em>include</em> identity secrets if they must be used to generate/process
messages or membership changes. Better protocols would <em>not</em> need them, so
that they may be wiped from memory during a session, reducing the attack
surface. However, even in the latter case, session secrets still contain
<em>entropy</em> from identity secrets; weaker threat models that exclude this are
better for modelling attacks on the RNG than on memory; see <a class="reference internal" href="references.html#ssek" id="id3">[11SSEK]</a>.</p>
</dd>
<dt>Corrupt member (of some targets)</dt>
<dd><p class="first">This may be either a genuine but malicious member, or a external attacker
that has exploited the running system of a genuine member. Unfortunately, it
is probably impossible to distinguish the two cases.</p>
<p class="last">We include this for completeness as &#8220;the worst case&#8221;, though it&#8217;s unclear if
this is fundamentally different from many repeated applications of &#8220;leak
session secrets&#8221;; more research is needed here. One difference could be that
under the corruption attack, there is no parallel honest instance <em>and</em> the
attacker can observe secret computations that don&#8217;t touch memory, e.g.
collecting, using, then immediately discarding entropy.</p>
</dd>
</dl>
<p>Now, we enumerate all the concrete things an attacker <em>might</em> be able to do, by
applying these attacks to our model of session mechanics. For simplicity, we
only consider individual attacks; a full precise formal treatment will need to
consider multiple attacks across multiple sessions. In the following, the term
&#8220;target&#8221; refers to the direct target of a secrets-leak or corruption, and the
term &#8220;current&#8221; refers to when that attack happens.</p>
<dl class="docutils">
<dt>Older sessions (i.e. already-closed)</dt>
<dd><ul class="first last simple">
<li>read session events (i.e. decrypt/verify messages and membership changes);
<a class="footnote-reference" href="#uenc" id="id4">[3]</a> <a class="footnote-reference" href="#fwds" id="id5">[4]</a></li>
<li>(participation is not applicable, since the session is already closed).</li>
</ul>
</dd>
<dt>Current sessions (i.e. opened, not-yet-closed)</dt>
<dd><ul class="first last simple">
<li>read session events; <a class="footnote-reference" href="#fwds" id="id6">[4]</a></li>
<li>participate as targets (i.e. auth/encrypt messages and initiate/confirm
membership changes; this includes making false claims or omissions in the
<em>contents</em> of messages, such as receipt acknowledgements, which may break
other properties like authenticity of ordering or message membership, or
invariants on the application layer);</li>
<li>participate as non-targets (e.g. against the targets); <a class="footnote-reference" href="#kcis" id="id7">[5]</a></li>
<li>(these may apply differently to newer or older parts of the session).</li>
</ul>
</dd>
<dt>Newer sessions (i.e. not-yet-opened)</dt>
<dd><ul class="first last simple">
<li>open/join sessions as targets, read their events and participate in them;</li>
<li>open/join sessions (etc.) as non-targets (e.g. invite a target or intercept
or respond to their invitations), read and participate in them; <a class="footnote-reference" href="#kcis" id="id8">[5]</a></li>
<li>read session events, participate as targets, or as non-targets, in sessions
whose establishment was not compromised as in the previous points. <a class="footnote-reference" href="#rene" id="id9">[6]</a></li>
</ul>
</dd>
</dl>
<p>Next, we&#8217;ll discuss the unavoidable consequences of attacks using these powers,
and from this try to get an intuitive idea on the best thing we <em>might</em> be able
to defend against:</p>
<dl class="docutils">
<dt>Active attack</dt>
<dd><p class="first">Present cryptographic systems have security theorems that state that, when
implemented correctly and assuming the hardness of certain mathematical
problems, an attacker at this level cannot break the confidentiality and
authenticity of message contents, or the authenticity of membership &#8211; and
therefore also anything that derives their security from these properties.</p>
<p class="last">However, side channel attacks against the confidentiality of membership are
feasible; hiding this sufficiently well (and even defining models for all of
the side channels) is still a research problem, and it is not known what the
maximum possible protection is.</p>
</dd>
<dt>Leak identity secrets (and active attack)</dt>
<dd>By definition, the attacker may open/join sessions <em>as targets</em>, then read
their events and participate in them. However, we may be able to prevent them
from doing anything else.</dd>
<dt>Leak session secrets (and active attack)</dt>
<dd>By definition, the attacker may participate <em>as targets</em> in current sessions,
and read its events, for at least several messages into the future &#8211; until
members mix in new entropy secret to the attacker. If session secrets also
include identity secrets, the attacker also gains the abilities mentioned in
the previous point. However, we may be able to prevent them from doing
anything else.</dd>
<dt>Corrupt insider (and active attack)</dt>
<dd>This is similar to the above, except that there is no chance of recovery by
members mixing in entropy, until after the corruption is healed.</dd>
</dl>
<p>As just discussed, under certain attacks we can&#8217;t protect confidentiality, even
for actions of members not directly targeted by that attack. Such is the nature
of our group session model. But we <em>could</em> try to protect a related property:</p>
<dl class="docutils">
<dt><strong>Confidential authenticity</strong></dt>
<dd>Only the intended consumers should be able to verify the information. (Of
course, attackers who break confidentiality, may choose to believe the
information even without being able to verify it.)</dd>
</dl>
<p>For every type of information where we want authenticity <em>and</em> confidentiality,
we should also aim for confidential authenticity &#8211; if the attacker should be
unable to read its contents, they should also be unable to verify <em>anything</em>
about it. As noted earlier, this is useful not merely for its own sake, but is
essential if we want to protect the confidentiality of membership. Furthermore,
this property can be removed on a higher layer, e.g. an opt-in method to sign
all messages with public signature keys, but once lost it cannot be regained.
So it is safer to default to <em>having</em> this property.</p>
<p>Against an active attacker, this means that verification must be executable
only by other members, i.e. depend on session secrets. Against a corrupt
insider, who is already allowed to perform verification, this means we must
choose a deniable or zero-knowledge authentication mechanism, so that they are
at least unable to pass this certainty-in-belief onto third parties.</p>
<table class="docutils footnote" frame="void" id="uenc" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>It may be theoretically possible to restrict this only to messages
authored <em>by non-targets</em> (excluding messages that the <em>target</em> sends), and
likewise for membership changes. However, it&#8217;s unlikely that the complexity
of any solution is worth the benefit, since (a) for every member, we&#8217;d need
to arrange that they can&#8217;t derive the ability to decrypt their own messages
from their session secrets, and (b) even with this protection, the attacker
can still just compromise a second member to get the missing pieces.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fwds" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> The inability for an attacker to decrypt past messages is commonly
known as <em>forward secrecy</em>. Currently are several slightly different formal
models for this, but the general idea is the same.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="kcis" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> This attack is commonly known as <em>key compromise impersonation</em>.
As with forward secrecy, there are slightly different models for this.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rene" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[6]</a></td><td>For example, the protocol may offer the ability for members to check
out-of-band, after establishment, that shared session secrets match up as
expected, and if so then be convinced that the session has full security
(i.e. session establishment was not tampered with) <em>even if members know</em>
that identity secrets were already compromised before establishment.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Mega_logo_gradient.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Background</a><ul>
<li><a class="reference internal" href="#model-and-mechanics">1.1. Model and mechanics</a></li>
<li><a class="reference internal" href="#security-properties">1.2. Security properties</a></li>
<li><a class="reference internal" href="#threat-models">1.3. Threat models</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Multi-Party Encrypted Messaging Protocol</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="topics.html"
                        title="next chapter">2. Topics</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/background.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="topics.html" title="2. Topics"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Multi-Party Encrypted Messaging Protocol"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Multi-Party Encrypted Messaging Protocol design document 0.1-4-g75e6b2d</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; <a href="copyright.html">Copyright</a> 2015, Mega Limited, Auckland, New Zealand.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>